package evaluator

import scala.collection.immutable.{Stream, PagedSeq}
import scala.util.parsing.combinator._
import scala.util.parsing.input.PagedSeqReader
import scala.util.matching.Regex

import java.io.{Reader, File, FileReader}
import java.io.{Reader, File, FileReader, BufferedReader}

/** parses out square cells and other case classes*/
object CellParser extends JavaTokenParsers {
  def double:Parser[Double] = floatingPointNumber ^^ (d => d.toDouble)
  def geoLoc:Parser[GeoLoc] = "GeoLoc(" ~> double ~ ("," ~> double) <~ ")" ^^ {
    case lat ~ lon => GeoLoc(lat, lon)
  }
  def optGeoLoc:Parser[Option[GeoLoc]] = ("None" ^^ {_ => None}) | ("Some(" ~> geoLoc <~ ")" ^^ {l => Some(l)})
  def squareCell:Parser[SquareCell] = "SquareCell(" ~> double ~ 
  ("," ~> double) ~ ("," ~> double) ~ ("," ~> double) ~ ("," ~> optGeoLoc) <~ ")" ^^ {
    case lat1 ~ lat2 ~ lon1 ~ lon2 ~ oCen => SquareCell(lat1, lat2, lon1, lon2, oCen)
  }

  def parseSquareCell(sqs:String):SquareCell = parseAll(squareCell, sqs).get
}

/** convenience object for loading a file for line-by-line reading.
  * just apply it to a reader! 
  */
object StringStream {
  @inline protected def die(reader:Reader, msg:Option[String]=None) = {msg foreach (println _); reader.close; Stream.empty}
  def apply(reader:Reader):Stream[String] = {
    readNext(new BufferedReader(reader))
  }
  def readNext(br:BufferedReader):Stream[String]= try {
    Option(br.readLine()) match {
      case Some(line) => line #:: readNext(br)
      case None => die(br)
    }
  } catch {
    case _ => die(br, Some("exception"))
  }
}

/** line based file parser. */
abstract class LineStreamParser[A] extends JavaTokenParsers {
  /**neat little way to close a reader and provide end of stream, with optional message.*/
  @inline protected def die(reader:Reader, msg:Option[String]=None) = {msg foreach (println _); reader.close; Stream.empty}

  /** Produces a stream over items, using parser combinators*/
  def extract(in:Reader):Stream[A] = StringStream(in) flatMap { line =>
    parseAll(streamItem, line) match {
      case Success(result, _) => Some(result)
      case NoSuccess(msg, rest) => None
    }
  }

  def streamItem:Parser[A]
}

object QuotedsFile extends LineStreamParser[List[String]] {
  def innerStringLiteral: Parser[String] = "\"" ~> """([^"\p{Cntrl}\\]|\\[\\/bfnrt]|\\u[a-fA-F0-9]{4})*""".r <~ "\""
  def streamItem = rep1sep(innerStringLiteral, regex(",".r))
}

/** parses output of label propagation
  * cf https://github.com/parthatalukdar/junto/blob/master/examples/simple/simple_config 
  */
object LabelLineParsers extends LineStreamParser[LabelPropDoc] {
  def double:Parser[Double] = floatingPointNumber ^^ (d => d.toDouble)
  def labelWeight:Parser[LabelWeight] = """[\w\d_]+""".r ~ double ^^ {
    case l ~ w => LabelWeight(l, w)
  }
  def streamItem = """\w+""".r ~ rep(labelWeight) ^^ {
    case i ~ lws => LabelPropDoc(i, lws)
  }
}

object GoldLabelLineParsers extends LineStreamParser[GoldLabel] {
  def streamItem = """\w+""".r ~ """[\w\d_]+""".r  <~ floatingPointNumber ^^ { case i ~ l => i -> l}
}

object Loaders {
  def open(path:String):Reader = new FileReader(new File(path))
  /** loads up a stream of cell id, square cells from a file generated by get_cells.*/
  def loadCells(cellsFile:String):Stream[(String, SquareCell)] = {
    QuotedsFile.extract(open(cellsFile)) map {
      case List(s1, s2) => (s1 -> CellParser.parseSquareCell(s2))
      case _ => throw new Exception("loadCells broke because QuotedsFile produced something weird")
    }
  }

  /** given a path to the locs file produced by get_cells, returns a stream over (article id/title, cell id) pairs*/
  def loadDocLocs(locsFile:String):Stream[(String, String)] = {
    QuotedsFile.extract(open(locsFile)) map {
      case List(s1, s2) => (s1 -> s2)
      case _ => throw new Exception("loadCells broke because QuotedsFile produced something weird")
    }
  }

  def loadLabelled(lpFile:String):Stream[LabelPropDoc] = LabelLineParsers.extract(open(lpFile))

  def loadGold(goldFile:String):Stream[GoldLabel] = GoldLabelLineParsers.extract(open(goldFile))
}
